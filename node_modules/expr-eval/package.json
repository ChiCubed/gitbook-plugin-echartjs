{
  "_args": [
    [
      {
        "raw": "expr-eval@^1.0.0",
        "scope": null,
        "escapedName": "expr-eval",
        "name": "expr-eval",
        "rawSpec": "^1.0.0",
        "spec": ">=1.0.0 <2.0.0",
        "type": "range"
      },
      "/Users/albert/GitBook/Library/chicubed/2017-study-notes/gitbook-plugin-echartjs"
    ]
  ],
  "_from": "expr-eval@>=1.0.0 <2.0.0",
  "_id": "expr-eval@1.0.0",
  "_inCache": true,
  "_location": "/expr-eval",
  "_nodeVersion": "6.9.1",
  "_npmOperationalInternal": {
    "host": "packages-18-east.internal.npmjs.com",
    "tmp": "tmp/expr-eval-1.0.0.tgz_1483386831169_0.6428212849423289"
  },
  "_npmUser": {
    "name": "silentmatt",
    "email": "email@matthewcrumley.com"
  },
  "_npmVersion": "3.10.8",
  "_phantomChildren": {},
  "_requested": {
    "raw": "expr-eval@^1.0.0",
    "scope": null,
    "escapedName": "expr-eval",
    "name": "expr-eval",
    "rawSpec": "^1.0.0",
    "spec": ">=1.0.0 <2.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/expr-eval/-/expr-eval-1.0.0.tgz",
  "_shasum": "0a5ef2cd7d0d745c3a490d2cf53bca3400b2965d",
  "_shrinkwrap": null,
  "_spec": "expr-eval@^1.0.0",
  "_where": "/Users/albert/GitBook/Library/chicubed/2017-study-notes/gitbook-plugin-echartjs",
  "author": {
    "name": "Matthew Crumley"
  },
  "bugs": {
    "url": "https://github.com/silentmatt/expr-eval/issues"
  },
  "dependencies": {},
  "description": "Mathematical expression evaluator",
  "devDependencies": {
    "chai": "^3.5.0",
    "eslint": "^3.4.0",
    "eslint-config-semistandard": "^7.0.0-beta.0",
    "eslint-config-standard": "^6.0.0",
    "eslint-plugin-promise": "^3.3.1",
    "eslint-plugin-standard": "^2.0.0",
    "istanbul": "^0.4.5",
    "mocha": "^3.1.0",
    "rollup": "^0.36.0",
    "rollup-plugin-uglify": "^1.0.1"
  },
  "directories": {
    "test": "test"
  },
  "dist": {
    "shasum": "0a5ef2cd7d0d745c3a490d2cf53bca3400b2965d",
    "tarball": "https://registry.npmjs.org/expr-eval/-/expr-eval-1.0.0.tgz"
  },
  "files": [
    "dist/"
  ],
  "gitHead": "fb3b840b409e3db6f7e9335a6431a1338a1fca5e",
  "homepage": "https://github.com/silentmatt/expr-eval#readme",
  "keywords": [
    "expression",
    "math",
    "evaluate",
    "eval",
    "function",
    "parser"
  ],
  "license": "MIT",
  "main": "dist/bundle.js",
  "maintainers": [
    {
      "name": "silentmatt",
      "email": "email@matthewcrumley.com"
    }
  ],
  "name": "expr-eval",
  "optionalDependencies": {},
  "readme": "JavaScript Expression Evaluator\n===============================\n\n[![npm](https://img.shields.io/npm/v/expr-eval.svg)](https://www.npmjs.com/package/expr-eval)\n[![Build Status](https://travis-ci.org/silentmatt/expr-eval.svg?branch=master)](https://travis-ci.org/silentmatt/expr-eval)\n\nDescription\n-------------------------------------\n\nParses and evaluates mathematical expressions. It's a safer and more\nmath-oriented alternative to using JavaScript’s `eval` function for mathematical\nexpressions.\n\nIt has built-in support for common math operators and functions. Additionally,\nyou can add your own JavaScript functions. Expressions can be evaluated\ndirectly, or compiled into native JavaScript functions.\n\nInstallation\n-------------------------------------\n\n    npm install expr-eval\n\nBasic Usage\n-------------------------------------\n\n    var Parser = require('expr-eval').Parser;\n\n    var parser = new Parser();\n    var expr = parser.parse('2 * x + 1');\n    console.log(expr.evaluate({ x: 3 })); // 7\n\n    // or\n    Parser.evaluate('6 * x', { x: 7 }) // 42\n\nDocumentation\n-------------------------------------\n\n### Parser ###\n\nParser is the main class in the library. It has as single `parse` method, and\n\"static\" methods for parsing and evaluating expressions.\n\n#### Parser()\n\nConstructs a new `Parser` instance.\n\n#### parse(expression: string)\n\nConvert a mathematical expression into an `Expression` object.\n\n#### Parser.parse(expression: string)\n\nStatic equivalent of `new Parser().parse(expression)`.\n\n#### Parser.evaluate(expression: string, variables?: object)\n\nParse and immediately evaluate an expression using the values and functions from\nthe `variables` object.\n\nParser.evaluate(expr, vars) is equivalent to calling\nParser.parse(expr).evaluate(vars).\n\n### Expression ###\n\n`Parser.parse(str)` returns an `Expression` object. `Expression`s are similar to\nJavaScript functions, i.e. they can be \"called\" with variables bound to\npassed-in values. In fact, they can even be converted into JavaScript\nfunctions.\n\n#### evaluate(variables?: object)\n\nEvaluate the expression, with variables bound to the values in {variables}. Each\nvariable in the expression is bound to the corresponding member of the\n`variables` object. If there are unbound variables, `evaluate` will throw an\nexception.\n\n    js> expr = Parser.parse(\"2 ^ x\");\n    (2^x)\n    js> expr.evaluate({ x: 3 });\n    8\n\n#### substitute(variable: string, expression: Expression | string | number)\n\nCreate a new `Expression` with the specified variable replaced with another\nexpression. This is similar to function composition. If `expression` is a string\nor number, it will be parsed into an `Expression`.\n\n    js> expr = Parser.parse(\"2 * x + 1\");\n    ((2*x)+1)\n    js> expr.substitute(\"x\", \"4 * x\");\n    ((2*(4*x))+1)\n    js> expr2.evaluate({ x: 3 });\n    25\n\n#### simplify(variables: object)\n\nSimplify constant sub-expressions and replace variable references with literal\nvalues. This is basically a partial evaluation, that does as much of the\ncalculation as it can with the provided variables. Function calls are not\nevaluated (except the built-in operator functions), since they may not be\ndeterministic.\n\nSimplify is pretty simple. For example, it doesn’t know that addition and\nmultiplication are associative, so `((2*(4*x))+1)` from the previous example\ncannot be simplified unless you provide a value for x. `2*4*x+1` can however,\nbecause it’s parsed as `(((2*4)*x)+1)`, so the `(2*4)` sub-expression will be\nreplaced with \"8\", resulting in `((8*x)+1)`.\n\n    js> expr = Parser.parse(\"x * (y * atan(1))\").simplify({ y: 4 });\n    (x*3.141592653589793)\n    js> expr.evaluate({ x: 2 });\n    6.283185307179586\n\n#### variables()\n\nGet an array of the unbound variables in the expression.\n\n    js> expr = Parser.parse(\"x * (y * atan(1))\");\n    (x*(y*atan(1)))\n    js> expr.variables();\n    x,y\n    js> expr.simplify({ y: 4 }).variables();\n    x\n\n#### symbols()\n\nGet an array of variables, including any built-in functions used in the\nexpression.\n\n    js> expr = Parser.parse(\"min(x, y, z)\");\n    (min(x, y, z))\n    js> expr.variables();\n    min,x,y,z\n    js> expr.simplify({ y: 4, z: 5 }).variables();\n    min,x\n\n#### toString()\n\nConvert the expression to a string. `toString()` surrounds every sub-expression\nwith parentheses (except literal values, variables, and function calls), so\nit’s useful for debugging precedence errors.\n\n#### toJSFunction(parameters: array | string, variables?: object)\n\nConvert an `Expression` object into a callable JavaScript function. `parameters`\nis an array of parameter names, or a string, with the names separated by commas.\n\nIf the optional `variables` argument is provided, the expression will be\nsimplified with variables bound to the supplied values.\n\n    js> expr = Parser.parse(\"x + y + z\");\n    ((x + y) + z)\n    js> f = expr.toJSFunction(\"x,y,z\");\n    [Function] // function (x, y, z) { return x + y + z; };\n    js> f(1, 2, 3)\n    6\n    js> f = expr.toJSFunction(\"y,z\", { x: 100 });\n    [Function] // function (y, z) { return 100 + y + z; };\n    js> f(2, 3)\n    105\n\n### Expression Syntax ###\n\nThe parser accepts a pretty basic grammar. It's similar to normal JavaScript\nexpressions, but is more math-oriented. For example, the `^` operator is\nexponentiation, not xor.\n\n#### Operator Precedence\n\nOperator              | Associativity | Description\n:-------------------- | :------------ | :----------\n(...)                 | None          | Grouping\nf(), x.y              | Left          | Function call, property access\n!                     | Left          | Factorial\n^                     | Right         | Exponentiation\n+, -, not, sqrt, etc. | Right         | Unary prefix operators (see below for the full list)\n\\*, /, %              | Left          | Multiplication, division, remainder\n+, -, \\|\\|            | Left          | Addition, subtraction, concatenation\n==, !=, >=, <=, >, <  | Left          | Equals, not equals, etc.\nand                   | Left          | Logical AND\nor                    | Left          | Logical OR\nx ? y : z             | Right         | Ternary conditional (if x then y else z)\n\n#### Unary operators\n\nThe parser has several built-in \"functions\" that are actually unary operators.\nThe primary difference between these and functions are that they can only accept\nexactly one argument, and parentheses are optional. With parentheses, they have\nthe same precedence as function calls, but without parentheses, they keep their\nnormal precedence (just below `^`). For example, `sin(x)^2` is equivalent to\n`(sin x)^2`, and `sin x^2` is equivalent to `sin(x^2)`.\n\nThe unary `+` and `-` operators are an exception, and always have their normal\nprecedence.\n\nOperator | Description\n:------- | :----------\n-x       | Negation\n+x       | Unary plus. This converts it's operand to a number, but has no other effect.\nx!       | Factorial (x * (x-1) * (x-2) * … * 2 * 1). gamma(x + 1) for non-integers.\nabs x    | Absolute value (magnatude) of x\nacos x   | Arc cosine of x (in radians)\nacosh x  | Hyperbolic arc cosine of x (in radians)\nasin x   | Arc sine of x (in radians)\nasinh x  | Hyperbolic arc sine of x (in radians)\natan x   | Arc tangent of x (in radians)\natanh x  | Hyperbolic arc tangent of x (in radians)\nceil x   | Ceiling of x — the smallest integer that’s >= x\ncos x    | Cosine of x (x is in radians)\ncosh x   | Hyperbolic cosine of x (x is in radians)\nexp x    | e^x (exponential/antilogarithm function with base e)\nfloor x  | Floor of x — the largest integer that’s <= x\nlength x | String length of x\nln x     | Natural logarithm of x\nlog x    | Natural logarithm of x (synonym for ln, not base-10)\nlog10 x  | Base-10 logarithm of x\nnot x    | Logical NOT operator\nround x  | X, rounded to the nearest integer, using \"gradeschool rounding\"\nsin x    | Sine of x (x is in radians)\nsinh x   | Hyperbolic sine of x (x is in radians)\nsqrt x   | Square root of x. Result is NaN (Not a Number) if x is negative.\ntan x    | Tangent of x (x is in radians)\ntanh x   | Hyperbolic tangent of x (x is in radians)\ntrunc x  | Integral part of a X, looks like floor(x) unless for negative number\n\n#### Pre-defined functions\n\nBesides the \"operator\" functions, there are several pre-defined functions. You\ncan provide your own, by binding variables to normal JavaScript functions.\nThese are not evaluated by simplify.\n\nFunction     | Description\n:----------- | :----------\nrandom(n)    | Get a random number in the range [0, n). If n is zero, or not provided, it defaults to 1.\nfac(n)       | n! (factorial of n: \"n * (n-1) * (n-2) * … * 2 * 1\") Deprecated. Use the ! operator instead.\nmin(a,b,…)   | Get the smallest (minimum) number in the list\nmax(a,b,…)   | Get the largest (maximum) number in the list\nhypot(a,b)   | Hypotenuse, i.e. the square root of the sum of squares of its arguments.\npyt(a, b)    | Alias for hypot\npow(x, y)    | Equivalent to x^y. For consistency with JavaScript's Math object.\natan2(y, x)  | Arc tangent of x/y. i.e. the angle between (0, 0) and (x, y) in radians.\nif(c, a, b)  | Function form of c ? a : b\n\n### Tests ###\n\nTo run tests, you need:\n\n1. [Install NodeJS](https://github.com/nodejs/node)\n2. Install Mocha `npm install -g mocha`\n3. Install Chai `npm install chai`\n4. Execute `mocha`\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/silentmatt/expr-eval.git"
  },
  "scripts": {
    "build": "rollup -c rollup.config.js && rollup -c rollup-min.config.js",
    "coverage": "npm run build && istanbul cover _mocha",
    "lint": "eslint parser.js test rollup.config.js rollup-min.config.js",
    "prepublish": "npm run build",
    "test": "npm run build && mocha"
  },
  "version": "1.0.0"
}
